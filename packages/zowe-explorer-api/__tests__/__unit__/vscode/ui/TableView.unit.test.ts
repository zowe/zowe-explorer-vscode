/**
 * This program and the accompanying materials are made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Copyright Contributors to the Zowe Project.
 *
 */

import { join } from "path";
import { Table, TableBuilder, WebView } from "../../../../src";
import { env, EventEmitter, Uri, window } from "vscode";
import * as crypto from "crypto";
import { diff } from "deep-object-diff";
import * as fs from "fs";

jest.mock("fs");
function createGlobalMocks() {
    const mockPanel = {
        dispose: jest.fn(),
        onDidDispose: jest.fn(),
        webview: { asWebviewUri: (uri) => uri.toString(), onDidReceiveMessage: jest.fn(), postMessage: jest.fn() },
    };
    // Mock `vscode.window.createWebviewPanel` to return a usable panel object
    const createWebviewPanelMock = jest.spyOn(window, "createWebviewPanel").mockReturnValueOnce(mockPanel as any);
    const spyReadFile = jest.fn((path, encoding, callback) => {
        callback(null, "file contents");
    });
    Object.defineProperty(fs, "readFile", { value: spyReadFile, configurable: true });

    return {
        createWebviewPanelMock,
        context: {
            extensionPath: "/a/b/c/zowe-explorer",
            extension: {
                id: "Zowe.vscode-extension-for-zowe",
            },
        },
        updateWebviewMock: jest.spyOn((Table.View as any).prototype, "updateWebview"),
    };
}

// Table.View unit tests
describe("Table.View", () => {
    describe("constructor", () => {
        it("handles a missing title in the data object", () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, {} as any);
            expect((view as any).title).toBe("Table view");
        });
    });

    describe("getUris", () => {
        it("returns the URIs from the WebView base class", () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, false, { title: "Table" } as any);
            const buildPath = join(globalMocks.context.extensionPath, "src", "webviews");
            const scriptPath = join(buildPath, "dist", "table-view", "table-view.js");
            expect(view.getUris()).toStrictEqual({
                disk: {
                    build: Uri.parse(buildPath),
                    script: Uri.parse(scriptPath),
                    codicons: undefined,
                    css: undefined,
                },
                resource: {
                    build: buildPath,
                    script: scriptPath,
                    codicons: undefined,
                    css: undefined,
                },
            });
        });
    });

    describe("getHtml", () => {
        it("returns the HTML content generated by the WebView base class", () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, false, { title: "Table" } as any);
            expect(view.getHtml()).toStrictEqual(view.panel.webview.html);
        });
    });

    describe("updateWebview", () => {
        it("calls postMessage on the panel and sends the data to the webview", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, false, { title: "Table" } as any);

            // case 1: Post message was not successful; updateWebview returns false
            const postMessageMock = jest.spyOn(view.panel.webview, "postMessage").mockResolvedValueOnce(false);
            await expect((view as any).updateWebview()).resolves.toBe(false);
            expect(postMessageMock).toHaveBeenCalledWith({
                command: "ondatachanged",
                data: {
                    actions: { all: [] },
                    columns: [],
                    contextOpts: { all: [] },
                    rows: [],
                    title: "Table",
                },
            });

            // case 2: Post message was successful; updateWebview returns true and event is fired
            const emitterFireMock = jest.spyOn(EventEmitter.prototype, "fire");
            postMessageMock.mockResolvedValueOnce(true);
            await expect((view as any).updateWebview()).resolves.toBe(true);
            const tableData = {
                actions: { all: [] },
                columns: [],
                contextOpts: { all: [] },
                rows: [],
                title: "Table",
            };
            expect(postMessageMock).toHaveBeenCalledWith({
                command: "ondatachanged",
                data: tableData,
            });
            expect(emitterFireMock).toHaveBeenCalledWith(tableData);
            postMessageMock.mockRestore();
            emitterFireMock.mockClear();

            // case 2: Post message was successful; updateWebview was previously called
            // result: Uses lastUpdated cache, returns true and fires the event
            postMessageMock.mockResolvedValueOnce(true);
            const mockNewRow = { a: 3, b: 2, c: 1 };
            (view as any).data.rows = [mockNewRow];
            await expect((view as any).updateWebview()).resolves.toBe(true);
            expect(postMessageMock).toHaveBeenCalledWith({
                command: "ondatachanged",
                data: {
                    actions: { all: [] },
                    columns: [],
                    contextOpts: { all: [] },
                    rows: [mockNewRow],
                    title: "Table",
                },
            });
            expect(emitterFireMock).toHaveBeenCalledWith(diff((view as any).lastUpdated, (view as any).data));
            postMessageMock.mockRestore();
        });
    });

    describe("getId", () => {
        it("returns a valid ID for the table view", () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, false, { title: "Table" } as any);
            const randomUuidMock = jest.spyOn(crypto, "randomUUID").mockReturnValueOnce("foo-bar-baz-qux-quux");
            expect(view.getId()).toBe("Table-foo##Zowe.vscode-extension-for-zowe");
            expect(randomUuidMock).toHaveBeenCalled();
        });
    });

    describe("setTitle", () => {
        it("returns false if it was unable to send the new title", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Stable Table of Cables" } as any);
            globalMocks.updateWebviewMock.mockResolvedValueOnce(false);
            await expect(view.setTitle("Unstable Table of Cables")).resolves.toBe(false);
        });

        it("returns true if it successfully sent the new title", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Stable Table of Cables" } as any);
            globalMocks.updateWebviewMock.mockResolvedValueOnce(true);
            await expect(view.setTitle("Unstable Table of Cables")).resolves.toBe(true);
            expect((view as any).data.title).toBe("Unstable Table of Cables");
        });
    });

    describe("setOptions", () => {
        it("returns false if it was unable to send the new options", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table" } as any);
            globalMocks.updateWebviewMock.mockResolvedValueOnce(false);
            await expect(
                view.setOptions({
                    debug: true,
                    pagination: false,
                })
            ).resolves.toBe(false);
        });

        it("returns true if it successfully sent the new options", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Stable Table of Cables" } as any);
            globalMocks.updateWebviewMock.mockResolvedValueOnce(true);

            // case 1: No options were previously defined
            await expect(
                view.setOptions({
                    debug: true,
                    pagination: false,
                })
            ).resolves.toBe(true);
            expect((view as any).data.options.debug).toBe(true);
            expect((view as any).data.options.pagination).toBe(false);

            globalMocks.updateWebviewMock.mockResolvedValueOnce(true);
            // case 2: Options were previously specified
            await expect(
                view.setOptions({
                    paginationPageSize: 0,
                })
            ).resolves.toBe(true);
            expect((view as any).data.options).toStrictEqual({
                debug: true,
                pagination: false,
                paginationPageSize: 0,
            });
        });
    });

    describe("setColumns", () => {
        it("returns false if it was unable to send the new columns", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table" } as any);
            globalMocks.updateWebviewMock.mockResolvedValueOnce(false);
            await expect(view.setColumns([{ field: "apple" }, { field: "banana" }, { field: "orange" }])).resolves.toBe(false);
        });

        it("returns true if it successfully sent the new options", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Stable Table of Cables" } as any);
            globalMocks.updateWebviewMock.mockResolvedValueOnce(true);
            const cols = [
                { field: "apple", valueFormatter: (data: { value: Table.ContentTypes }) => `${data.value?.toString()} apples` },
                { field: "banana", comparator: (_valueA, _valueB, _nodeA, _nodeB, _isDescending) => -1, colSpan: (_params) => 2 },
                { field: "orange", rowSpan: (_params) => 2 },
            ];
            await expect(view.setColumns(cols)).resolves.toBe(true);
            expect((view as any).data.columns).toStrictEqual(
                cols.map((col) => ({
                    ...col,
                    colSpan: col.colSpan?.toString(),
                    comparator: col.comparator?.toString(),
                    rowSpan: col.rowSpan?.toString(),
                    valueFormatter: col.valueFormatter?.toString(),
                }))
            );
        });
    });

    describe("onMessageReceived", () => {
        it("does nothing if no command is provided", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ changing display" } as any);
            const onTableDisplayChangedFireMock = jest.spyOn((view as any).onTableDisplayChangedEmitter, "fire");
            globalMocks.updateWebviewMock.mockClear();
            const tableData = { rows: [{ a: 1, b: 1, c: 1 }] };
            await view.onMessageReceived({
                payload: tableData,
            });
            expect(onTableDisplayChangedFireMock).not.toHaveBeenCalledWith(tableData);
            expect(globalMocks.updateWebviewMock).not.toHaveBeenCalled();
        });

        it("fires the onTableDisplayChanged event when handling the 'ondisplaychanged' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ changing display" } as any);
            const onTableDisplayChangedFireMock = jest.spyOn((view as any).onTableDisplayChangedEmitter, "fire");
            const tableData = { rows: [{ a: 1, b: 1, c: 1 }] };
            await view.onMessageReceived({
                command: "ondisplaychanged",
                payload: tableData,
            });
            expect(onTableDisplayChangedFireMock).toHaveBeenCalledWith(tableData);
        });

        it("fires the onTableDataEdited event when handling the 'ontableedited' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, false, { title: "Table w/ editable columns" } as any);
            await view.setColumns([{ field: "a", editable: true }, { field: "b" }, { field: "c" }]);
            const onTableDataEditedFireMock = jest.spyOn((view as any).onTableDataEditedEmitter, "fire");
            const tableData = { rows: [{ a: 1, b: 1, c: 1 }] };
            const editData = {
                value: 2,
                oldValue: tableData.rows[0].a,
                field: "a",
                rowIndex: 0,
            };
            await view.onMessageReceived({
                command: "ontableedited",
                payload: editData,
            });
            expect(onTableDataEditedFireMock).toHaveBeenCalledWith(editData);
        });

        it("calls updateWebview when handling the 'ready' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ changing display" } as any);
            globalMocks.updateWebviewMock.mockImplementation();
            await view.onMessageReceived({
                command: "ready",
            });
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            globalMocks.updateWebviewMock.mockRestore();
        });

        it("should handle the case where 'GET_LOCALIZATION' is the command sent", async () => {
            const globalMocks = await createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, false, { title: "Table" } as any);
            const postMessageSpy = jest.spyOn(view.panel.webview, "postMessage");
            await view.onMessageReceived({ command: "GET_LOCALIZATION" });
            expect(postMessageSpy).toHaveBeenCalledWith({
                command: "GET_LOCALIZATION",
                payload: "file contents",
                requestId: undefined,
            });
            globalMocks.updateWebviewMock.mockRestore();
        });

        it("calls vscode.env.clipboard.writeText when handling the 'copy' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ copy" } as any);
            const writeTextMock = jest.spyOn(env.clipboard, "writeText").mockImplementation();
            const mockWebviewMsg = {
                command: "copy",
                payload: { row: { a: 1, b: 1, c: 1 } },
            };
            await view.onMessageReceived(mockWebviewMsg);
            expect(writeTextMock).toHaveBeenCalledWith(JSON.stringify(mockWebviewMsg.payload.row));
            writeTextMock.mockRestore();
        });

        it("calls vscode.env.clipboard.writeText when handling the 'copy-cell' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ copy-cell" } as any);
            const writeTextMock = jest.spyOn(env.clipboard, "writeText").mockImplementation();
            const mockWebviewMsg = {
                command: "copy-cell",
                payload: { cell: 1, row: { a: 1, b: 1, c: 1 } },
            };
            await view.onMessageReceived(mockWebviewMsg);
            expect(writeTextMock).toHaveBeenCalledWith(mockWebviewMsg.payload.cell);
            writeTextMock.mockRestore();
        });

        it("does nothing for a command that doesn't exist as a context option or row action", async () => {
            const globalMocks = createGlobalMocks();
            const data = {
                title: "Some table",
                rows: [{ a: 1, b: 1, c: 1 }],
                columns: [],
                contextOpts: {
                    all: [],
                },
                actions: {
                    all: [],
                },
            };
            const view = new Table.View(globalMocks.context as any, false, data);
            const writeTextMock = jest.spyOn(env.clipboard, "writeText");
            const mockWebviewMsg = {
                command: "nonexistent-action",
                payload: { row: data.rows[0] },
            };
            await view.onMessageReceived(mockWebviewMsg);
            expect(writeTextMock).not.toHaveBeenCalled();
            expect(globalMocks.updateWebviewMock).not.toHaveBeenCalled();
        });

        it("runs the callback for an action that exists", async () => {
            const globalMocks = createGlobalMocks();
            const allCallbackMock = jest.fn();
            const zeroCallbackMock = jest.fn();
            const multiCallbackMock = jest.fn();
            const data = {
                title: "Some table",
                rows: [{ a: 1, b: 1, c: 1 }],
                columns: [],
                contextOpts: {
                    all: [],
                },
                actions: {
                    all: [
                        {
                            title: "Some action",
                            command: "some-action",
                            callback: {
                                typ: "cell",
                                fn: (_view: Table.View, _cell: Table.ContentTypes) => {
                                    allCallbackMock();
                                },
                            },
                        } as Table.Action,
                        {
                            title: "Multi action",
                            command: "multi-action",
                            callback: {
                                typ: "multi-row",
                                fn: (_view: Table.View, _row: Record<number, Table.RowData>) => {
                                    multiCallbackMock();
                                },
                            },
                        } as Table.Action,
                    ],
                    0: [
                        {
                            title: "Zero action",
                            command: "zero-action",
                            callback: {
                                typ: "single-row",
                                fn: (_view: Table.View, _row: Table.RowInfo) => {
                                    zeroCallbackMock();
                                },
                            },
                        } as Table.Action,
                    ],
                },
            };
            const view = new Table.View(globalMocks.context as any, false, data);
            const writeTextMock = jest.spyOn(env.clipboard, "writeText");

            // case 1: A cell action that exists for all rows
            const mockWebviewMsg = {
                command: "some-action",
                payload: { cell: data.rows[0].a, row: data.rows[0] },
                rowIndex: 0,
            };
            await view.onMessageReceived(mockWebviewMsg);
            expect(writeTextMock).not.toHaveBeenCalled();
            expect(globalMocks.updateWebviewMock).not.toHaveBeenCalled();
            expect(allCallbackMock).toHaveBeenCalled();

            // case 2: A single-row action that exists for one row
            const mockNextWebviewMsg = {
                command: "zero-action",
                payload: { cell: data.rows[0].a, row: data.rows[0] },
                rowIndex: 0,
            };
            await view.onMessageReceived(mockNextWebviewMsg);
            expect(writeTextMock).not.toHaveBeenCalled();
            expect(globalMocks.updateWebviewMock).not.toHaveBeenCalled();
            expect(zeroCallbackMock).toHaveBeenCalled();

            // case 2: A multi-row action that exists for all rows
            const mockFinalWebviewMsg = {
                command: "multi-action",
                payload: { cell: data.rows[0].a, rows: data.rows },
                rowIndex: 1,
            };
            await view.onMessageReceived(mockFinalWebviewMsg);
            expect(writeTextMock).not.toHaveBeenCalled();
            expect(globalMocks.updateWebviewMock).not.toHaveBeenCalled();
            expect(multiCallbackMock).toHaveBeenCalled();
        });
    });

    describe("setContent", () => {
        it("sets the rows on the internal data structure and calls updateWebview", async () => {
            const globalMocks = createGlobalMocks();
            const mockRow = { red: 255, green: 0, blue: 255 };
            const data = { title: "Table w/ content", rows: [] };
            const view = new Table.View(globalMocks.context as any, data as any);
            globalMocks.updateWebviewMock.mockImplementation();
            await view.setContent([mockRow]);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.rows[0]).toStrictEqual(mockRow);
            globalMocks.updateWebviewMock.mockRestore();
        });
    });

    describe("addColumns", () => {
        it("sets the columns on the internal data structure and calls updateWebview", async () => {
            const globalMocks = createGlobalMocks();
            const mockCols = [
                { field: "name", sort: "desc", colSpan: (_params) => 2, rowSpan: (_params) => 2 },
                {
                    field: "address",
                    sort: "asc",
                    comparator: (_valueA, _valueB, _nodeA, _nodeB, _isDescending) => 1,
                    valueFormatter: (data: { value }) => `Located at ${(data.value as string).toString()}`,
                },
            ] as Table.ColumnOpts[];
            const data = { title: "Table w/ cols", columns: [], rows: [] };
            const view = new Table.View(globalMocks.context as any, data as any);
            globalMocks.updateWebviewMock.mockImplementation();
            await view.addColumns(...mockCols);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.columns).toStrictEqual(
                mockCols.map((col) => ({
                    ...col,
                    colSpan: col.colSpan?.toString(),
                    comparator: col.comparator?.toString(),
                    rowSpan: col.rowSpan?.toString(),
                    valueFormatter: col.valueFormatter?.toString(),
                }))
            );
            globalMocks.updateWebviewMock.mockRestore();
        });
    });

    describe("addContent", () => {
        it("adds the rows to the internal data structure and calls updateWebview", async () => {
            const globalMocks = createGlobalMocks();
            const mockRow = { blue: true, yellow: false, violet: true };
            const data = { title: "Table w/ no initial rows", rows: [] };
            const view = new Table.View(globalMocks.context as any, data as any);
            globalMocks.updateWebviewMock.mockImplementation();
            await view.addContent(mockRow);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.rows[0]).toStrictEqual(mockRow);
            globalMocks.updateWebviewMock.mockRestore();
        });
    });

    describe("addContextOption", () => {
        it("adds the context option with conditional to the internal data structure and calls updateWebview", async () => {
            const globalMocks = createGlobalMocks();
            const data = { title: "Table w/ no initial rows", contextOpts: { all: [] }, rows: [] };
            const view = new Table.View(globalMocks.context as any, data as any);
            globalMocks.updateWebviewMock.mockImplementation();

            // case 1: Adding a context menu option with conditional to all rows
            const contextOpt = {
                title: "Add to favorites",
                command: "add-to-favorites",
                callback: {
                    typ: "single-row",
                    fn: (_data) => {},
                },
                condition: (_data) => true,
            } as Table.ContextMenuOption;
            await view.addContextOption("all", contextOpt);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.contextOpts["all"]).toStrictEqual([contextOpt]);

            // case 2: Adding a context menu option with conditional to one row
            const singleRowContextOpt = {
                title: "Save for later",
                command: "save-for-later",
                callback: {
                    typ: "single-row",
                    fn: (_data) => {},
                },
                condition: (_data) => true,
            } as Table.ContextMenuOption;
            await view.addContextOption(0, singleRowContextOpt);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.contextOpts[0]).toStrictEqual([singleRowContextOpt]);
            globalMocks.updateWebviewMock.mockRestore();
        });

        it("adds the context option without conditional to the internal data structure and calls updateWebview", async () => {
            const globalMocks = createGlobalMocks();
            const data = { title: "Table w/ no initial rows", contextOpts: { all: [] }, rows: [] };
            const view = new Table.View(globalMocks.context as any, data as any);
            globalMocks.updateWebviewMock.mockImplementation();

            // case 1: Adding a context menu option without conditional to all rows
            const contextOpt = {
                title: "Remove from favorites",
                command: "rm-from-favorites",
                callback: {
                    typ: "single-row",
                    fn: (_data) => {},
                },
            } as Table.ContextMenuOption;
            await view.addContextOption("all", contextOpt);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.contextOpts["all"]).toStrictEqual([contextOpt]);

            // case 2: Adding a context menu option without conditional to one row
            const singleRowContextOpt = {
                title: "Add to history",
                command: "add-to-history",
                callback: {
                    typ: "single-row",
                    fn: (_data) => {},
                },
            } as Table.ContextMenuOption;
            await view.addContextOption(0, singleRowContextOpt);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.contextOpts[0]).toStrictEqual([singleRowContextOpt]);
            globalMocks.updateWebviewMock.mockRestore();
        });
    });

    describe("addAction", () => {
        it("adds the action with conditional to the internal data structure and calls updateWebview", async () => {
            const globalMocks = createGlobalMocks();
            const data = { title: "Table w/ no initial rows", actions: { all: [] }, rows: [] };
            const view = new Table.View(globalMocks.context as any, data as any);
            globalMocks.updateWebviewMock.mockImplementation();

            // case 1: Adding an action to all rows
            const action = {
                title: "Add to history",
                command: "add-to-history",
                callback: {
                    typ: "single-row",
                    fn: (_data) => {},
                },
                condition: (_data) => true,
            } as Table.ContextMenuOption;
            await view.addAction("all", action);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.actions["all"]).toStrictEqual([action]);

            // case 2: Adding an action to one row
            const singleRowAction = {
                title: "Learn more",
                command: "learn-more",
                callback: {
                    typ: "single-row",
                    fn: (_data) => {},
                },
                condition: (_data) => true,
            } as Table.ContextMenuOption;
            await view.addAction(0, singleRowAction);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.actions[0]).toStrictEqual([singleRowAction]);
            globalMocks.updateWebviewMock.mockRestore();
        });

        it("adds the action without conditional to the internal data structure and calls updateWebview", async () => {
            const globalMocks = createGlobalMocks();
            const data = { title: "Table w/ no initial rows", actions: { all: [] }, rows: [] };
            const view = new Table.View(globalMocks.context as any, data as any);
            globalMocks.updateWebviewMock.mockImplementation();

            // case 1: Adding an action without conditional to all rows
            const action = {
                title: "Remove from history",
                command: "rm-from-history",
                callback: {
                    typ: "single-row",
                    fn: (_data) => {},
                },
            } as Table.ContextMenuOption;
            await view.addAction("all", action);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.actions["all"]).toStrictEqual([action]);

            // case 2: Adding an action without conditional to one row
            const singleRowAction = {
                title: "Learn less",
                command: "learn-less",
                callback: {
                    typ: "single-row",
                    fn: (_data) => {},
                },
            } as Table.ContextMenuOption;
            await view.addAction(0, singleRowAction);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            expect((view as any).data.actions[0]).toStrictEqual([singleRowAction]);
            globalMocks.updateWebviewMock.mockRestore();
        });
    });

    describe("getContent", () => {
        it("returns the content provided to the table view", () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, false, { rows: [{ d: true, e: false, f: true }], title: "Table" } as any);
            expect(view.getContent()).toStrictEqual([{ d: true, e: false, f: true }]);
        });
    });

    describe("updateRow", () => {
        it("updates the rows on the internal data structure and calls updateWebview", async () => {
            const globalMocks = createGlobalMocks();
            const mockRow = { a: 2, b: 2, c: 2 };

            // case 1: Update the contents of a single row with new contents
            const data = { title: "Table w/ content", rows: [{ a: 1, b: 2, c: 3 }] };
            const view = new Table.View(globalMocks.context as any, data as any);
            globalMocks.updateWebviewMock.mockImplementation();
            await view.updateRow(0, mockRow);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            globalMocks.updateWebviewMock.mockClear();

            // case 2: Remove a row from the table
            await view.updateRow(0, null);
            expect((view as any).data.rows.length).toBe(0);
            expect(globalMocks.updateWebviewMock).toHaveBeenCalled();
            globalMocks.updateWebviewMock.mockRestore();
        });
    });

    describe("async condition checking", () => {
        it("handles check-condition-for-action with sync function condition", async () => {
            const globalMocks = createGlobalMocks();
            const conditionFn = jest.fn().mockReturnValue(true);
            const action = {
                title: "Test Action",
                command: "test-action",
                condition: conditionFn,
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ conditional actions",
                actions: { all: [action] },
                contextOpts: { all: [] },
                columns: [{ field: "name" }, { field: "value" }],
                rows: [{ name: "test", value: 123 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-condition-for-action",
                requestId: "test-request-123",
                payload: {
                    actionId: "test-action",
                    row: { name: "test", value: 123 },
                    rowIndex: 0,
                },
            };

            await view.onMessageReceived(message);

            expect(conditionFn).toHaveBeenCalledWith({ name: "test", value: 123 });
            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "condition-for-action-result",
                requestId: "test-request-123",
                payload: true,
            });
        });

        it("handles check-condition-for-action with async function condition", async () => {
            const globalMocks = createGlobalMocks();
            const conditionFn = jest.fn().mockResolvedValue(false);
            const action = {
                title: "Async Action",
                command: "async-action",
                condition: conditionFn,
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ async conditional actions",
                actions: { all: [action] },
                contextOpts: { all: [] },
                columns: [{ field: "name" }, { field: "value" }],
                rows: [{ name: "test", value: 456 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-condition-for-action",
                requestId: "async-test-456",
                payload: {
                    actionId: "async-action",
                    row: { name: "test", value: 456 },
                    rowIndex: 0,
                },
            };

            await view.onMessageReceived(message);

            expect(conditionFn).toHaveBeenCalledWith({ name: "test", value: 456 });
            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "condition-for-action-result",
                requestId: "async-test-456",
                payload: false,
            });
        });

        it("handles check-condition-for-action with string condition", async () => {
            const globalMocks = createGlobalMocks();
            const action = {
                title: "String Condition Action",
                command: "string-condition",
                condition: "(data) => data.value > 100",
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ string conditional actions",
                actions: { all: [action] },
                contextOpts: { all: [] },
                columns: [{ field: "name" }, { field: "value" }],
                rows: [{ name: "test", value: 456 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-condition-for-action",
                requestId: "string-test-789",
                payload: {
                    actionId: "string-condition",
                    row: { name: "test", value: 456 },
                    rowIndex: 0,
                },
            };

            await view.onMessageReceived(message);

            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "condition-for-action-result",
                requestId: "string-test-789",
                payload: true,
            });
        });

        it("handles check-condition-for-action with context menu option", async () => {
            const globalMocks = createGlobalMocks();
            const conditionFn = jest.fn().mockReturnValue(true);
            const contextOpt = {
                title: "Context Action",
                command: "context-action",
                condition: conditionFn,
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.ContextMenuOption;

            const data = {
                title: "Table w/ conditional context menu",
                actions: { all: [] },
                contextOpts: { all: [contextOpt] },
                columns: [{ field: "name" }, { field: "value" }],
                rows: [{ name: "test", value: 789 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-condition-for-action",
                requestId: "context-test-789",
                payload: {
                    actionId: "context-action",
                    row: { name: "test", value: 789 },
                    rowIndex: 0,
                },
            };

            await view.onMessageReceived(message);

            expect(conditionFn).toHaveBeenCalledWith({ name: "test", value: 789 });
            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "condition-for-action-result",
                requestId: "context-test-789",
                payload: true,
            });
        });

        it("handles check-condition-for-action when action not found", async () => {
            const globalMocks = createGlobalMocks();
            const data = {
                title: "Table w/ no actions",
                actions: { all: [] },
                contextOpts: { all: [] },
                columns: [{ field: "name" }, { field: "value" }],
                rows: [{ name: "test", value: 123 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-condition-for-action",
                requestId: "not-found-test",
                payload: {
                    actionId: "non-existent-action",
                    row: { name: "test", value: 123 },
                    rowIndex: 0,
                },
            };

            await view.onMessageReceived(message);

            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "condition-for-action-result",
                requestId: "not-found-test",
                payload: false,
            });
        });

        it("handles check-condition-for-action when condition throws error", async () => {
            const globalMocks = createGlobalMocks();
            const conditionFn = jest.fn().mockImplementation(() => {
                throw new Error("Test condition error");
            });
            const action = {
                title: "Error Action",
                command: "error-action",
                condition: conditionFn,
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ error conditional actions",
                actions: { all: [action] },
                contextOpts: { all: [] },
                columns: [{ field: "name" }, { field: "value" }],
                rows: [{ name: "test", value: 123 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-condition-for-action",
                requestId: "error-test",
                payload: {
                    actionId: "error-action",
                    row: { name: "test", value: 123 },
                    rowIndex: 0,
                },
            };

            await view.onMessageReceived(message);

            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "condition-for-action-result",
                requestId: "error-test",
                payload: false,
            });
        });
    });

    describe("dynamic titles", () => {
        it("handles get-dynamic-title-for-action with function title", async () => {
            const globalMocks = createGlobalMocks();
            const titleFn = jest.fn().mockReturnValue("Dynamic Title");
            const action = {
                title: titleFn,
                command: "dynamic-title-action",
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ dynamic titles",
                actions: { all: [action] },
                contextOpts: { all: [] },
                rows: [{ name: "test", value: 123 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data as any);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "get-dynamic-title-for-action",
                requestId: "dynamic-title-test-123",
                payload: {
                    actionId: "dynamic-title-action",
                    row: { name: "test", value: 123 },
                },
            };

            await view.onMessageReceived(message);

            expect(titleFn).toHaveBeenCalledWith({ name: "test", value: 123 });
            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "dynamic-title-for-action-result",
                requestId: "dynamic-title-test-123",
                payload: "Dynamic Title",
            });
        });

        it("handles get-dynamic-title-for-action with async function title", async () => {
            const globalMocks = createGlobalMocks();
            const titleFn = jest.fn().mockResolvedValue("Async Dynamic Title");
            const action = {
                title: titleFn,
                command: "async-dynamic-title-action",
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ async dynamic titles",
                actions: { all: [action] },
                contextOpts: { all: [] },
                rows: [{ name: "test", value: 456 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data as any);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "get-dynamic-title-for-action",
                requestId: "async-dynamic-title-test-456",
                payload: {
                    actionId: "async-dynamic-title-action",
                    row: { name: "test", value: 456 },
                },
            };

            await view.onMessageReceived(message);

            expect(titleFn).toHaveBeenCalledWith({ name: "test", value: 456 });
            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "dynamic-title-for-action-result",
                requestId: "async-dynamic-title-test-456",
                payload: "Async Dynamic Title",
            });
        });

        it("handles get-dynamic-title-for-action with string title", async () => {
            const globalMocks = createGlobalMocks();
            const action = {
                title: "Static Title",
                command: "static-title-action",
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ static titles",
                actions: { all: [action] },
                contextOpts: { all: [] },
                rows: [{ name: "test", value: 789 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data as any);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "get-dynamic-title-for-action",
                requestId: "static-title-test-789",
                payload: {
                    actionId: "static-title-action",
                    row: { name: "test", value: 789 },
                },
            };

            await view.onMessageReceived(message);

            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "dynamic-title-for-action-result",
                requestId: "static-title-test-789",
                payload: "Static Title",
            });
        });

        it("handles get-dynamic-title-for-action when title function throws error", async () => {
            const globalMocks = createGlobalMocks();
            const titleFn = jest.fn().mockImplementation(() => {
                throw new Error("Test title error");
            });
            const action = {
                title: titleFn,
                command: "error-title-action",
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ error titles",
                actions: { all: [action] },
                contextOpts: { all: [] },
                rows: [{ name: "test", value: 123 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data as any);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "get-dynamic-title-for-action",
                requestId: "error-title-test",
                payload: {
                    actionId: "error-title-action",
                    row: { name: "test", value: 123 },
                },
            };

            await view.onMessageReceived(message);

            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "dynamic-title-for-action-result",
                requestId: "error-title-test",
                payload: "error-title-action", // falls back to command
            });
        });
    });

    describe("hide conditions", () => {
        it("handles check-hide-condition-for-action with function returning true", async () => {
            const globalMocks = createGlobalMocks();
            const hideConditionFn = jest.fn().mockReturnValue(true);
            const action = {
                title: "Hide Me",
                command: "hide-action",
                hideCondition: hideConditionFn,
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ hide conditions",
                actions: { all: [action] },
                contextOpts: { all: [] },
                rows: [{ name: "test", value: 123 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data as any);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-hide-condition-for-action",
                requestId: "hide-test-123",
                payload: {
                    actionId: "hide-action",
                    row: { name: "test", value: 123 },
                },
            };

            await view.onMessageReceived(message);

            expect(hideConditionFn).toHaveBeenCalledWith({ name: "test", value: 123 });
            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "hide-condition-for-action-result",
                requestId: "hide-test-123",
                payload: true,
            });
        });

        it("handles check-hide-condition-for-action with async function", async () => {
            const globalMocks = createGlobalMocks();
            const hideConditionFn = jest.fn().mockResolvedValue(true);
            const action = {
                title: "Hide Me Async",
                command: "hide-action-async",
                hideCondition: hideConditionFn,
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/ hide conditions",
                actions: { all: [action] },
                contextOpts: { all: [] },
                rows: [{ name: "test", value: 123 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data as any);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-hide-condition-for-action",
                requestId: "hide-test-async-123",
                payload: {
                    actionId: "hide-action-async",
                    row: { name: "test", value: 123 },
                },
            };

            await view.onMessageReceived(message);

            expect(hideConditionFn).toHaveBeenCalledWith({ name: "test", value: 123 });
            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "hide-condition-for-action-result",
                requestId: "hide-test-async-123",
                payload: true,
            });
        });

        it("handles check-hide-condition-for-action with no hideCondition", async () => {
            const globalMocks = createGlobalMocks();
            const action = {
                title: "Don't Hide Me",
                command: "no-hide-action",
                callback: { typ: "single-row", fn: jest.fn() },
            } as Table.Action;

            const data = {
                title: "Table w/o hide conditions",
                actions: { all: [action] },
                contextOpts: { all: [] },
                rows: [{ name: "test", value: 456 }],
            };
            const view = new Table.View(globalMocks.context as any, false, data as any);

            const mockPostMessage = jest.fn();
            (view as any).panel = { webview: { postMessage: mockPostMessage } };

            const message = {
                command: "check-hide-condition-for-action",
                requestId: "no-hide-test-456",
                payload: {
                    actionId: "no-hide-action",
                    row: { name: "test", value: 456 },
                },
            };

            await view.onMessageReceived(message);

            expect(mockPostMessage).toHaveBeenCalledWith({
                command: "hide-condition-for-action-result",
                requestId: "no-hide-test-456",
                payload: false, // defaults to false
            });
        });
    });

    describe("waitForAPI", () => {
        it("should resolve when api-ready is received", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "API Ready Test" } as any);

            let resolved = false;
            const promise = view.waitForAPI().then(() => {
                resolved = true;
            });

            expect(resolved).toBe(false);

            await view.onMessageReceived({ command: "api-ready" });

            await promise;
            expect(resolved).toBe(true);
        });

        it("should resolve immediately if api is already ready", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "API Already Ready Test" } as any);

            await view.onMessageReceived({ command: "api-ready" });

            let resolved = false;
            await view.waitForAPI().then(() => {
                resolved = true;
            });
            expect(resolved).toBe(true);
        });
    });

    describe("AG Grid API methods", () => {
        let view: Table.View;
        let requestSpy: jest.SpyInstance;

        beforeEach(() => {
            const globalMocks = createGlobalMocks();
            view = new Table.View(globalMocks.context as any, { title: "API Test" } as any);
            requestSpy = jest.spyOn(view, "request").mockResolvedValue(true);
        });

        afterEach(() => {
            requestSpy.mockRestore();
        });

        it("should call request for getPageSize", async () => {
            await view.getPageSize();
            expect(requestSpy).toHaveBeenCalledWith("get-page-size");
        });

        it("should call request for setPageSize", async () => {
            await view.setPageSize(50);
            expect(requestSpy).toHaveBeenCalledWith("set-page-size", 50);
        });

        it("should call request for getGridState", async () => {
            await view.getGridState();
            expect(requestSpy).toHaveBeenCalledWith("get-grid-state");
        });

        it("should call request for setGridState", async () => {
            const state = { colId: "test", sort: "asc" };
            await view.setGridState(state);
            expect(requestSpy).toHaveBeenCalledWith("set-grid-state", state);
        });

        it("should call request for setPage", async () => {
            await view.setPage(2);
            expect(requestSpy).toHaveBeenCalledWith("set-page", 2);
        });

        it("should call request for getPage", async () => {
            await view.getPage();
            expect(requestSpy).toHaveBeenCalledWith("get-page");
        });

        it("should call request for pinRows", async () => {
            const rows: Table.RowData[] = [{ id: 1 }, { id: 2 }];
            await view.pinRows(rows);
            expect(requestSpy).toHaveBeenCalledWith("pin-rows", { rows: { "0": { id: 1 }, "1": { id: 2 } } });
        });

        it("should call request for unpinRows", async () => {
            const rows: Table.RowData[] = [{ id: 1 }, { id: 2 }];
            await view.unpinRows(rows);
            expect(requestSpy).toHaveBeenCalledWith("unpin-rows", { rows: { "0": { id: 1 }, "1": { id: 2 } } });
        });

        it("should call request for getPinnedRows", async () => {
            await view.getPinnedRows();
            expect(requestSpy).toHaveBeenCalledWith("get-pinned-rows");
        });

        it("should call request for setPinnedRows", async () => {
            const rows: Table.RowData[] = [{ id: 1 }, { id: 2 }];
            await view.setPinnedRows(rows);
            expect(requestSpy).toHaveBeenCalledWith("set-pinned-rows", { rows });
        });
    });

    describe("request", () => {
        let view: Table.View;

        beforeEach(() => {
            const globalMocks = createGlobalMocks();
            view = new Table.View(globalMocks.context as any, { title: "Request Test" } as any);
            (view as any).panel = {
                webview: {
                    postMessage: jest.fn(),
                },
            };
        });

        xit("should resolve with payload on successful response", async () => {
            const postMessageMock = (view as any).panel.webview.postMessage.mockResolvedValue(true);

            const requestPromise = view.request("test-command", { data: "test-data" });

            // Need to get the requestId to simulate the response
            const lastCall = postMessageMock.mock.calls[0][0] as { requestId: string };
            const requestId = lastCall.requestId;

            process.nextTick(async () => {
                await view.onMessageReceived({
                    requestId,
                    payload: { result: "success" },
                });
            });

            await expect(requestPromise).resolves.toEqual({ result: "success" });
            expect(postMessageMock).toHaveBeenCalledWith(
                expect.objectContaining({
                    command: "test-command",
                    payload: { data: "test-data" },
                })
            );
        });

        it("should reject when postMessage fails", async () => {
            (view as any).panel.webview.postMessage.mockResolvedValue(false);

            const requestPromise = view.request("test-command");

            await expect(requestPromise).rejects.toThrow("Failed to send message to webview");
        });

        xit("should reject when webview sends an error", async () => {
            const postMessageMock = (view as any).panel.webview.postMessage.mockResolvedValue(true);

            const requestPromise = view.request("test-command");

            const lastCall = postMessageMock.mock.calls[0][0] as { requestId: string };
            const requestId = lastCall.requestId;

            process.nextTick(async () => {
                await view.onMessageReceived({
                    requestId,
                    error: "Something went wrong in the webview",
                });
            });

            await expect(requestPromise).rejects.toThrow("Something went wrong in the webview");
        });
    });
});

// Table.Instance unit tests
describe("Table.Instance", () => {
    describe("dispose", () => {
        it("disposes of the table view using the function in the base class", () => {
            const globalMocks = createGlobalMocks();
            const builder = new TableBuilder(globalMocks.context as any)
                .addRows([
                    { a: 1, b: 2, c: 3, d: false, e: 5 },
                    { a: 3, b: 2, c: 1, d: true, e: 6 },
                ])
                .addColumns([{ field: "a" }, { field: "b" }, { field: "c" }, { field: "d" }, { field: "e" }]);
            const disposeMock = jest.spyOn((WebView as any).prototype, "dispose").mockImplementationOnce(jest.fn());
            const instance = builder.build();
            instance.dispose();
            expect(disposeMock).toHaveBeenCalled();
        });
    });
});
